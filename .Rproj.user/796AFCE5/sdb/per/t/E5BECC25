{
    "collab_server" : "",
    "contents" : "# Haplotype Accumulation Curve Simulation\n\n##### Clear memory #####\n\nremove(list = ls())\n\n##### Load packages #####\n\nlibrary(investr)\nlibrary(mgcv)\nlibrary(scam)\n\n### GAM/SCAM/GP/Kriging\n\n#' Inverse Prediction Function\n#' \n#' Reverse predicts x for a given y.\n#' \n#' @param object: A fitted model object. \n#' objects).\n#' \n#' @param y: The response value of interest.\n#' \n#' @param x.name: Character string giving the name of the (single) independent \n#' variable.\n#' \n#' @param ... Additional arguments to be passed onto \\code{uniroot}.\n#' \n#' @export\ninv.predict <- function(object, y, x.name, ...) {\n  UseMethod(\"inv.predict\") \n}\n\n#' @rdname inv.predict\n#' @export\ninv.predict.default <- function(object, y, x.name, interval = FALSE, \n                                lower, upper, level = 0.95,...) {\n  x0.est <- uniroot(lower = lower, upper = upper, extendInt = \"yes\", ..., f = function(x) {\n    predFit(object, newdata = setNames(data.frame(x), x.name)) - y\n  })$root\n  res <- if (interval) {\n    lwr <- uniroot(lower = lower, upper = x0.est, extendInt = \"yes\", ..., f = function(x) {\n      predFit(object, newdata = setNames(data.frame(x), x.name), \n              interval = \"confidence\")[, \"upr\"] - y\n    })$root\n    upr <- uniroot(lower = x0.est, upper = upper, extendInt = \"yes\", ..., f = function(x) {\n      predFit(object, newdata = setNames(data.frame(x), x.name),\n              interval = \"confidence\")[, \"lwr\"] - y\n    })$root\n    lwr <- min(c(lwr, upr))\n    upr <- max(c(lwr, upr))\n    c(\"estimate\" = x0.est, \"lower\" = lwr, \"upper\" = upr)\n  } else {\n    x0.est\n  }\n  res\n}\n\n#' GAM prediction\n\n#' @rdname predFit\n#' @export\npredFit.gam <- function(object, newdata, type = c(\"link\", \"response\"), \n                        interval = c(\"none\", \"confidence\", \"prediction\"), \n                        level = 0.95, ...) {\n  type <- match.arg(type)\n  interval <- match.arg(interval)\n  res <- if (interval == \"none\") {\n    predict.gam(object, newdata = newdata, type = type, ...)\n  } else if (interval == \"confidence\") {\n    pred <- predict.gam(object, newdata = newdata, se.fit = TRUE, type = \"link\", \n                    ...)\n    out <- cbind(\"fit\" = pred$fit,\n                 \"lwr\" = pred$fit - pred$se.fit * stats::qnorm((level + 1) / 2),\n                 \"upr\" = pred$fit + pred$se.fit * stats::qnorm((level + 1) / 2))\n    if (type == \"response\") {\n      out <- apply(out, MARGIN = 2, FUN = function(x) {\n        stats::family(object)$linkinv(x)\n      })\n    }\n    out\n  } else {\n    stop(\"Prediction intervals are currently not supported for GAMs.\")\n  }\n  res\n}\n\n#' SCAM prediction\n\n#' @rdname predFit\n#' @export\npredFit.scam <- function(object, newdata, type = c(\"link\", \"response\"), \n                        interval = c(\"none\", \"confidence\", \"prediction\"), \n                        level = 0.95, ...) {\n  type <- match.arg(type)\n  interval <- match.arg(interval)\n  res <- if (interval == \"none\") {\n    predict.scam(object, newdata = newdata, type = type, ...)\n  } else if (interval == \"confidence\") {\n    pred <- predict.scam(object, newdata = newdata, se.fit = TRUE, type = \"link\", \n                    ...)\n    out <- cbind(\"fit\" = pred$fit,\n                 \"lwr\" = pred$fit - pred$se.fit * stats::qnorm((level + 1) / 2),\n                 \"upr\" = pred$fit + pred$se.fit * stats::qnorm((level + 1) / 2))\n    if (type == \"response\") {\n      out <- apply(out, MARGIN = 2, FUN = function(x) {\n        stats::family(object)$linkinv(x)\n      })\n    }\n    out\n  } else {\n    stop(\"Prediction intervals are currently not supported for SCAMs.\")\n  }\n  res\n}\n\n# ptm <- proc.time() \n\nN <- 50 ### How many individuals are in each permutation\nHstar <- 2 ### Assume we know how many total haplotypes are possible\n\nperm <- 10000 ### How many permutations are we considering\n\nspecs <- 1:N \n\n### Set up a container to hold the identity of each individual from each permutation\n\npop <- array(dim = c(perm, N))\n\n### Create an ID for each haplotype\n\nhaps <- as.character(1:Hstar)\n\n### Assign probabilities of occurrence to each haplotype, ensure they sum to 1\n### This is where we assume we \"know\" the distribution of haplotypes\n### Here, I have assumed they all occur with equal frequency, but you can change this to assume some dominant ones and some \n###  rare ones, whatever you want\n\n# probs <- rep(1/Hstar, Hstar) \nprobs <- c(0.5, 0.5)\n# probs <- runif(H) # random values from U(0, 1) distribution\n# probs <- sort(probs/sum(probs), decreasing = TRUE) \n\n### Generate permutations, we assume each permutation has N individuals, and we sample those individuals' haplotypes\n### from our probabilities\n\nfor(i in 1:perm){\n\tpop[i,] <- sample(haps, size = N, replace = TRUE, prob = probs)\n}\n\n### Make a matrix to hold the 1:N individuals from each permutation\n\nHAC.mat <- array(dim = c(perm, N))\n\nfor(j in specs){\n\tfor(i in 1:perm){\n\t\tind.index <- sample(specs, size = j, replace = FALSE) ## which individuals will we sample\n\t\thap.plot <- pop[i, ind.index]\t## pull those individuals from a permutation\n\t\tHAC.mat[i,j] <- length(unique(hap.plot))  ## how many haplotypes did we get for a given sampling intensity (j) from each         ### permutation (i)\n\t}\n}\n\n### Calculate the mean and CI for number of haplotypes at each sampling intensity (j)\n\nmeans <- apply(HAC.mat, MARGIN = 2, mean)\nlower <- apply(HAC.mat, MARGIN = 2, function(x) quantile(x, 0.025))\nupper <- apply(HAC.mat, MARGIN = 2, function(x) quantile(x, 0.975))\n\n### Plot the curve and frequency barplot\n\npar(mfrow = c(1, 2))\n\nplot(specs, means, type = \"n\", xlab= \"Specimens sampled\", ylab = \"Unique haplotypes\")\npolygon(x = c(specs, rev(specs)), y = c(lower, rev(upper)), col = \"gray\")\nlines(specs, means, lwd = 2)\n# HAC.bar <- barplot(N*probs, xlab = \"Unique haplotypes\", ylab = \"Specimens sampled\", names.arg = 1:H)\n\nd <- data.frame(specs, means)\n\n### Fit power law model\n\nHAC.mod <- lm(log(means) ~ log(specs), data = d)\nHAC.nls <- nls(means ~ a*specs^b, start=list(a = exp(coef(HAC.mod)[1]), b = coef(HAC.mod)[2]), data = d)\n\nAIC(HAC.nls)\n\n### Plot curve\n\nx <- specs\ncurve(coef(HAC.nls)[1]*x^coef(HAC.nls)[2], add = TRUE, from = 1, to = N, col = \"red\", lwd = 2)\n\n### Calculate N*\n\nHAC.invest <- invest(HAC.nls, y0 = Hstar, interval = \"inversion\", upper = 1000000)\nHAC.invest\n\n# GAMs\n\n\nHAC.cr <- gam(means ~ s(specs, bs = \"cr\", k = 10), optimizer = c(\"outer\", \"bfgs\"), data = d)\n\n####\n####\nxx <- seq(from = min(d$specs), to = max(d$specs), length = 500)\nyy <- predict(HAC.cr, newdata = data.frame(specs = xx))\nplot(d, ylim = c(0.8, 2.2))\nlines(xx, yy, type = \"l\")\nabline(h = Hstar, lty = 2, col = \"red\")  # looks like multiple solutions\n####\n####\n\nHAC.cr$aic\n\nHAC.cr <- inv.predict(HAC.cr, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 1000000)\nHAC.cr\n\n# GP/Kriging\n\nHAC.gps <- gam(means ~ s(specs, bs = \"gp\", k = 10, m = 1), optimizer = c(\"outer\", \"bfgs\"), data = d) # spherical\n\nHAC.gps$aic\n\ngam.check(HAC.gps)\n\nHAC.gps <- inv.predict(HAC.gps, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 1000000)\t\nHAC.gps\n\nHAC.gpe <- gam(means ~ s(specs, bs = \"gp\", k = 10, m = 2), optimizer = c(\"outer\", \"bfgs\"), data = d) # exponential\n\nHAC.gpe$aic\n\ngam.check(HAC.gpe)\n\nHAC.gpe <- inv.predict(HAC.gpe, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 1000000)\nHAC.gpe\n\n# SCAMs\n\nHAC.mpi <- scam(means ~ s(specs, bs = \"mpi\", k = 10), data = d) # mpi\n####\n####\nxx <- seq(from = min(d$specs), to = max(d$specs), length = 500)\nyy <- predict(HAC.mpi, newdata = data.frame(specs = xx))\nplot(d, ylim = c(0.8, 2.2))\nlines(xx, yy, type = \"l\")\nabline(h = Hstar, lty = 2, col = \"red\")  # looks like no solution?\n####\n####\n\n\nHAC.mpi$aic\n\ngam.check(HAC.mpi)\n\nHAC.mpi <- inv.predict(HAC.mpi, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 10)\t\t\nHAC.mpi\t\t\n\nHAC.cv <- scam(means ~ s(specs, bs = \"cv\", k = 10), data = d) # cv\n\nHAC.cv$aic\n\ngam.check(HAC.cv)\n\nHAC.cv <- inv.predict(HAC.cv, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 1000000)\t\t\nHAC.cv\t\n\nHAC.micv <- scam(means ~ s(specs, bs = \"micv\", k = 10), data = d) # micv\n\nHAC.micv$aic\n\ngam.check(HAC.micv)\n\nHAC.micv <- inv.predict(HAC.micv, y = Hstar, x.name = \"specs\", interval = TRUE, lower = 1, upper = 1000000)\t\t\nHAC.micv\t\t\t\n                   \n# proc.time() - ptm",
    "created" : 1501776224723.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2446438233",
    "id" : "E5BECC25",
    "lastKnownWriteTime" : 1501777141,
    "last_content_update" : 1501777141584,
    "path" : "C:/Users/greenweb/Downloads/HAC simulation.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}